package com.ethiopianairlines.pilot.presentation.admin.exams // Assuming this is for creating/editing one exam, not list

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
// ExamMapper is NOT needed here if the repository handles mapping to DTOs
import com.ethiopianairlines.pilot.domain.model.Exam // Domain model
import com.ethiopianairlines.pilot.domain.model.ExamCategory
import com.ethiopianairlines.pilot.domain.model.ExamDifficulty
import com.ethiopianairlines.pilot.domain.repository.ExamRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow // Import asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

// Renamed for clarity, assuming this UI state is for create/edit operations
sealed class ExamOperationUiState {
    object Initial : ExamOperationUiState()
    object Loading : ExamOperationUiState()
    object Success : ExamOperationUiState() // Could carry the created/updated exam ID or object
    data class Error(val message: String) : ExamOperationUiState()
}

@HiltViewModel
class ExamViewModel @Inject constructor( // Or ExamCreateEditViewModel
    private val examRepository: ExamRepository
) : ViewModel() {

    // Use asStateFlow() for the public StateFlow
    private val _uiState = MutableStateFlow<ExamOperationUiState>(ExamOperationUiState.Initial)
    val uiState: StateFlow<ExamOperationUiState> = _uiState.asStateFlow()

    fun createExam(
        title: String,
        description: String,
        categoryString: String, // Input from UI, e.g., "PILOT_TRAINEE" or "pilotTrainee"
        difficultyString: String, // Input from UI, e.g., "EASY" or "easy"
        durationMinutes: Int,
        isActive: Boolean
    ) {
        viewModelScope.launch {
            _uiState.value = ExamOperationUiState.Loading
            try {
                // Construct the DomainExam object.
                // Ensure categoryString and difficultyString are correctly converted.
                // If they come directly from an Enum.name() (e.g., "PILOT_TRAINEE"),
                // ExamCategory.valueOf() is fine.
                // If they come as backend strings (e.g., "pilotTrainee"), you'll need a reverse mapping or ensure
                // your UI provides the Enum.name() compatible string.
                // For simplicity, assuming categoryString/difficultyString are like "PILOT_TRAINEE", "EASY"

                val domainCategory = try {
                    ExamCategory.valueOf(categoryString.uppercase()).toString()
                } catch (e: IllegalArgumentException) {
                    // Handle invalid category string, maybe default or throw error to UI
                    _uiState.value = ExamOperationUiState.Error("Invalid category: $categoryString")
                    return@launch
                }

                val domainDifficulty = try {
                    ExamDifficulty.valueOf(difficultyString.uppercase()).toString()
                } catch (e: IllegalArgumentException) {
                    // Handle invalid difficulty string
                    _uiState.value = ExamOperationUiState.Error("Invalid difficulty: $difficultyString")
                    return@launch
                }

                val newDomainExam = Exam(
                    // id will be generated by backend, so it's often empty or default for new Exam
                    id = "", // Or let the default in DomainExam handle it if it's ""
                    title = title,
                    description = description,
                    category = domainCategory,
                    difficulty = domainDifficulty,
                    durationMinutes = durationMinutes,
                    passingScore = 70, // Default passing score for a new exam
                    totalQuestions = 0, // Default total questions for a new exam
                    isActive = isActive,
                    questions = emptyList(), // New exam starts with no questions
                    // createdAt and updatedAt will be set by backend
                    createdAt = "", // Or let default handle
                    updatedAt = ""  // Or let default handle
                )

                // Pass the DomainExam directly to the repository.
                // The repository will handle mapping it to the DTO (DataExam).
                examRepository.createExam(newDomainExam)

                _uiState.value = ExamOperationUiState.Success
            } catch (e: Exception) {
                _uiState.value = ExamOperationUiState.Error(e.message ?: "Failed to create exam")
            }
        }
    }

    // You would also have loadExamForEdit(id: String) and updateExam(...) methods here
    // For example:
    /*
    fun updateExam(
        examId: String, // ID of the exam to update
        title: String,
        description: String,
        categoryString: String,
        difficultyString: String,
        durationMinutes: Int,
        isActive: Boolean,
        passingScore: Int, // Existing or updated
        totalQuestions: Int, // Existing or updated
        questions: List<Question> // Existing or updated
        // Potentially createdAt if you need to preserve it, though backend usually manages
    ) {
        viewModelScope.launch {
            _uiState.value = ExamOperationUiState.Loading
            try {
                val domainCategory = ExamCategory.valueOf(categoryString.uppercase()).toString()
                val domainDifficulty = ExamDifficulty.valueOf(difficultyString.uppercase()).toString()

                val updatedDomainExam = Exam(
                    id = examId, // Crucial for update
                    title = title,
                    description = description,
                    category = domainCategory,
                    difficulty = domainDifficulty,
                    durationMinutes = durationMinutes,
                    passingScore = passingScore,
                    totalQuestions = totalQuestions,
                    isActive = isActive,
                    questions = questions, // Pass existing/updated questions
                    createdAt = "", // Typically not sent for update, or pre-filled if needed
                    updatedAt = ""  // Backend will set this
                )
                examRepository.updateExam(updatedDomainExam)
                _uiState.value = ExamOperationUiState.Success
            } catch (e: Exception) {
                _uiState.value = ExamOperationUiState.Error(e.message ?: "Failed to update exam")
            }
        }
    }
    */
}